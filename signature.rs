// Code generated by polyglot-rs v0.5.0, DO NOT EDIT.
// source: signature.proto

//use num_enum::TryFromPrimitive;
use polyglot::{Decoder, DecodingError, Encoder, Kind};
use std::collections::HashMap;
use std::convert::TryFrom;
use std::io;
use std::io::Cursor;

pub trait Encode {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> Result<&mut Cursor<Vec<u8>>, io::Error>;
}

pub trait Decode {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<Self>, DecodingError>
    where
        Self: Sized;
}

pub struct Context {
    pub request: Request,
    pub response: Response,
}

impl Encode for Context {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> Result<&mut Cursor<Vec<u8>>, io::Error> {
        self.request.encode(b)?;
        self.response.encode(b)?;
        Ok(b)
    }
}

impl Decode for Context {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<Context>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        Ok(Some(Context {
            request: Request::decode(b)?.ok_or(DecodingError::InvalidStruct)?,
            response: Response::decode(b)?.ok_or(DecodingError::InvalidStruct)?,
        }))
    }
}

pub struct Request {
    pub headers: HashMap<String, StringList>,
    pub method: String,
    pub content_length: i64,
    pub protocol: String,
    pub i_p: String,
    pub body: Vec<u8>,
}

impl Encode for Request {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> Result<&mut Cursor<Vec<u8>>, io::Error> {
        b.encode_string(&*self.method)?
            .encode_i64(self.content_length)?
            .encode_string(&*self.protocol)?
            .encode_string(&*self.i_p)?
            .encode_bytes(&self.body)?;

        b.encode_map(self.headers.len(), Kind::String, Kind::Any)?;
        for (k, v) in self.headers {
            b.encode_string(&*k)?;
            v.encode(b)?;
        }
        Ok(b)
    }
}

impl Decode for Request {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<Request>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        fn headers(
            b: &mut Cursor<&mut Vec<u8>>,
        ) -> Result<Option<HashMap<String, StringList>>, DecodingError> {
            if b.decode_none() {
                return Ok(None);
            }

            let size = b
                .decode_map(Kind::String, Kind::Any)
                .ok()
                .ok_or(DecodingError::InvalidU32)?;
            let mut map = HashMap::new();
            for _ in 0..size {
                let k = b.decode_string()?;
                let v = StringList::decode(b)?.ok_or(DecodingError::InvalidMap)?;
                map.insert(k, v);
            }
            Ok(Some(map))
        }
        Ok(Some(Request {
            method: b.decode_string()?,
            content_length: b.decode_i64()?,
            protocol: b.decode_string()?,
            i_p: b.decode_string()?,
            body: b.decode_bytes()?,
            headers: headers(b)?.ok_or(DecodingError::InvalidMap)?,
        }))
    }
}

pub struct Response {
    pub headers: HashMap<String, StringList>,
    pub status_code: i32,
    pub body: Vec<u8>,
}

impl Encode for Response {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> Result<&mut Cursor<Vec<u8>>, io::Error> {
        b.encode_i32(self.status_code)?.encode_bytes(&self.body)?;

        b.encode_map(self.headers.len(), Kind::String, Kind::Any)?;
        for (k, v) in self.headers {
            b.encode_string(&*k)?;
            v.encode(b)?;
        }
        Ok(b)
    }
}

impl Decode for Response {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<Response>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        fn headers(
            b: &mut Cursor<&mut Vec<u8>>,
        ) -> Result<Option<HashMap<String, StringList>>, DecodingError> {
            if b.decode_none() {
                return Ok(None);
            }

            let size = b
                .decode_map(Kind::String, Kind::Any)
                .ok()
                .ok_or(DecodingError::InvalidU32)?;
            let mut map = HashMap::new();
            for _ in 0..size {
                let k = b.decode_string()?;
                let v = StringList::decode(b)?.ok_or(DecodingError::InvalidMap)?;
                map.insert(k, v);
            }
            Ok(Some(map))
        }
        Ok(Some(Response {
            status_code: b.decode_i32()?,
            body: b.decode_bytes()?,
            headers: headers(b)?.ok_or(DecodingError::InvalidMap)?,
        }))
    }
}

pub struct StringList {
    pub value: Vec<String>,
}

impl Encode for StringList {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> Result<&mut Cursor<Vec<u8>>, io::Error> {
        b.encode_array(self.value.len(), Kind::String)?;
        for item in self.value {
            b.encode_string(&*item)?;
        }
        Ok(b)
    }
}

impl Decode for StringList {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<StringList>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        fn value_decode(
            b: &mut Cursor<&mut Vec<u8>>,
        ) -> Result<Option<Vec<String>>, DecodingError> {
            let value_size = b.decode_array(Kind::String)?;
            let mut temp = Vec::with_capacity(value_size);
            for _ in 0..value_size {
                temp.push(b.decode_string()?);
            }
            Ok(Some(temp))
        }
        Ok(Some(StringList {
            value: value_decode(b)?.ok_or(DecodingError::InvalidArray)?,
        }))
    }
}
